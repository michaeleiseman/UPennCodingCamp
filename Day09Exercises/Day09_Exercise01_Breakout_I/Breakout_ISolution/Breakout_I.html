<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout I</title>
    <style>
        canvas {
            border: 1px solid black
        }
    </style>
</head>
<body>
    <canvas width="400" height="600"></canvas>
    <script>
        class Board {
            constructor(canvas, rowsOfBricks, bricksPerRow, brickGap, brickHeight, paddleHeight, ballRadius, paddleWidth, ballX, ballY, ballVx, ballVy) {
                this.canvas = canvas;
                this.width = canvas.width;
                this.height = canvas.height;
                this.ctx = canvas.getContext("2d");
                this.rowsOfBricks = rowsOfBricks;
                this.bricsPerRow = bricksPerRow;
                this.brickGap = brickGap;
                this.brickHeight = brickHeight;
                this.brickWidth = (this.width - (bricksPerRow + 1) * brickGap) / bricksPerRow;
                this.init = function() {
                    this.bricks = this.buildBricks();
                };
                this.init();
                this.paddleHeight = paddleHeight;
                this.paddleLevel = this.height - brickGap - paddleHeight;
                this.ballRadius = ballRadius;
                this.paddle = new Paddle(this.width / 2, paddleWidth, this.paddleLevel, paddleHeight, this.ctx);
                this.ball = new Ball(ballX, ballY, ballVx, ballVy, ballRadius, this.ctx, this.bricks, this.paddle);
            }
            buildBricks() {
                let bricks = [];
                for(let y = this.brickGap; y < this.rowsOfBricks * (this.brickGap + this.brickHeight); y = y + this.brickGap + this.brickHeight) {
                    for(let x = this.brickGap; x < this.width - this.brickGap; x = x + this.brickWidth + this.brickGap) {
                        let brick = new Brick(x, y, this.brickWidth, this.brickHeight, this.ctx, this);
                        brick.draw(this.ctx);
                        bricks.push(brick);
                    }
                }
                return bricks;
            }
            remove(brick) {
                brick.clear();
                this.bricks.splice(this.bricks.indexOf(brick), 1);
            }
        }
        class Brick {
            constructor(x, y, brickWidth, brickHeight, ctx) {
                this.x = x;
                this.y = y;
                this.width = brickWidth;
                this.height = brickHeight;
                this.ctx = ctx;
                this.draw();
            }
            draw() {
                this.ctx.fillRect(this.x, this.y, this.width, this.height);
            }
            clear() {
                this.ctx.clearRect(this.x - 1, this.y - 1, this.width + 2, this.height + 2);
            }
        }
        class Paddle {
            constructor(centerX, width, paddleLevel, paddleHeight, ctx) {

                this.x = centerX - width / 2;
                this.width = width;
                this.y = paddleLevel;
                this.height = paddleHeight;
                this.ctx = ctx;
                this.draw();
            }
            draw() {
                this.ctx.fillRect(this.x , this.y, this.width, this.height);
            }
            determinePaddleDelta(event, paddle) {
                let key = event.key;
                if(key !== "ArrowRight" && key !== "ArrowLeft") {
                    return;
                }
                let delta = 10;
                if(key === "ArrowLeft") {
                    delta = -delta;
                }
                paddle.move(delta);
            }
            move(delta) {
                this.ctx.clearRect(this.x, this.y, this.width, this.height);
                this.x = this.x + delta;
                this.draw(this.ctx);
            }
        }
        class Ball {
            constructor(x, y, vx, vy, radius, ctx, bricks, paddle) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.radius = radius;
                this.ctx = ctx;
                this.bricks = bricks;
                this.paddle = paddle;
                this.draw(ctx);
                this.raf;
            }
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fillStyle = "black";
                ctx.fill();
            }
            clear(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius + 0.5, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fillStyle = "white";
                ctx.strokeStyle = "white";
                ctx.fill();
                ctx.stroke();
            }
            move() {
                this.clear(this.ctx);
                this.x = this.x + this.vx;
                this.y = this.y + this.vy;
                this.draw(this.ctx);
                this.adjustVelocityForCollisionWithWall();
                this.checkForCollisionWithBricks();
                if(this.y >= gameBoard.paddle.y - this.radius) {
                    this.adjustVelocityForCollisionWithPaddle();
                }
                
                if(this.y > gameBoard.height || this.bricks.length === 0) {
                    window.cancelAnimationFrame(gameBoard.raf);
                } else {
                    gameBoard.raf = window.requestAnimationFrame(function() {gameBoard.ball.move()});
                }
            }
            adjustVelocityForCollisionWithWall() {
                if (this.y + this.vy < this.radius) {
                    this.vy = -this.vy;
                }
                if (this.x + this.vx > gameBoard.width - this.radius || this.x + this.vx < this.radius) {
                    this.vx = -this.vx;
                }
            }
            checkForCollisionWithBricks() {
                for(let brick of this.bricks) {
                    if(this.hasCollidedWithBrick(brick)) {
                        this.adjustVelocityForCollisionWithBrick(brick);
                        return;
                    }
                }
            }
            hasCollidedWithBrick(brick) {
                return this.x > brick.x - this.radius && this.x < brick.x + brick.width + this.radius && this.y < brick.y + brick.height + this.radius && this.y > brick.y - this.radius;
            }
            adjustVelocityForCollisionWithBrick(brick) {
                if(this.x > brick.x && this.x < brick.x + brick.width) {
                    this.vy = -this.vy;
                } else {
                    this.vx = - this.vx;
                }
                gameBoard.remove(brick);
            }
            adjustVelocityForCollisionWithPaddle() {
                if(this.x < this.paddle.x || this.x > this.paddle.x + this.paddle.width) {
                    return;
                }
                this.vy = - this.vy;
                this.vx = Math.floor(10 * (this.x - this.paddle.x)/this.paddle.width - 5);
            }
        }
        let gameBoard = new Board(document.getElementsByTagName("canvas")[0], 6, 10, 5, 10, 10, 20, 200, 300, 300, 2, -1);
        document.addEventListener('keydown', function(event) {gameBoard.paddle.determinePaddleDelta(event, gameBoard.paddle)}, false);
        //let timer;
        //document.addEventListener('keydown', function(event) {timer = setInterval(gameBoard.paddle.determinePaddleDelta(event, gameBoard.paddle), 30)}, false);
        // document.addEventListener('keyup', function(event) {
        //     if(event.key === "ArrowLeft" || event.key === "ArrowRight") {
        //         clearInterval(timer);
        //     }
        // }, false);
        gameBoard.raf = window.requestAnimationFrame(function() {gameBoard.ball.move(gameBoard.ball)});

    </script>
</body>
</html>